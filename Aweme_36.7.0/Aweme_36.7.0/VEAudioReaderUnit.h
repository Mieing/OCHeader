@class VEAudioReaderUnitConfig, NSMutableDictionary, IESMMAudioLimiter, VEAudioResamplerUnit, NSArray, NSMutableArray, NSObject;
@protocol VEAudioPlayerProtocol, OS_dispatch_queue;

@interface VEAudioReaderUnit : IESMMObject

@property (retain, nonatomic) NSMutableArray *clipArray;
@property (retain, nonatomic) id<VEAudioPlayerProtocol> audioQueueUnit;
@property (nonatomic) struct AudioStreamBasicDescription { double mSampleRate; unsigned int mFormatID; unsigned int mFormatFlags; unsigned int mBytesPerPacket; unsigned int mFramesPerPacket; unsigned int mBytesPerFrame; unsigned int mChannelsPerFrame; unsigned int mBitsPerChannel; unsigned int mReserved; } asbd;
@property (nonatomic) BOOL useForPlayer;
@property (nonatomic) BOOL isSeeking;
@property (nonatomic) double seekTriggerTime;
@property (nonatomic) struct AudioBufferList { unsigned int x0; struct AudioBuffer { unsigned int x0; unsigned int x1; void *x2; } x1[1]; } *outBufferList;
@property (nonatomic) double maxDuration;
@property (nonatomic) double currentTime;
@property (nonatomic) double currentRateTime;
@property (nonatomic) double lastTime;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *playerQueue;
@property (nonatomic) BOOL stopThread;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *readerQueue;
@property (nonatomic) BOOL paused;
@property (nonatomic) BOOL resetBeforePlay;
@property (nonatomic) BOOL reEnqueueFailedBuffer;
@property (nonatomic) unsigned int numOfFramesToProcess;
@property (retain, nonatomic) NSMutableDictionary *assetClipLookupMap;
@property (retain, nonatomic) VEAudioReaderUnitConfig *config;
@property (readonly, nonatomic) unsigned int maxBufferListFrames;
@property (copy, nonatomic) id /* block */ audioVolumeCallBack;
@property (retain, nonatomic) IESMMAudioLimiter *audioLimiter;
@property (nonatomic) BOOL replaceAudioMix;
@property (nonatomic) BOOL enableAudioReaderOpt;
@property (nonatomic) BOOL enableProcessDataInQueue;
@property (nonatomic) BOOL audioReaderAnrFix;
@property (nonatomic) BOOL isRecordingScenes;
@property (retain, nonatomic) VEAudioResamplerUnit *resampleUnit;
@property (readonly, nonatomic) NSArray *assets;
@property (nonatomic) double playRate;
@property (nonatomic) double effectRecordRate;
@property (readonly, nonatomic) struct { long long x0; int x1; unsigned int x2; long long x3; } playCMTime;
@property (readonly, nonatomic) struct { long long x0; int x1; unsigned int x2; long long x3; } playCMRateTime;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *audioQueueOperQueue;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *processAudioQueue;
@property (copy, nonatomic) id /* block */ playDidStartBlock;
@property (copy, nonatomic) id /* block */ playDidEndBlock;
@property (copy, nonatomic) id /* block */ playDidPauseBlock;
@property (copy, nonatomic) id /* block */ playProgressBlock;
@property (readonly, nonatomic) double bufferListDuration;
@property (copy, nonatomic) id /* block */ audioEffectProcessBlock;
@property (copy, nonatomic) id /* block */ audioPlayStatusBlk;

+ (struct AudioStreamBasicDescription { double x0; unsigned int x1; unsigned int x2; unsigned int x3; unsigned int x4; unsigned int x5; unsigned int x6; unsigned int x7; unsigned int x8; })asbd;

- (id)initWithVideoData:(id)a0 withConfig:(id)a1;
- (double)getaudioVolumeKeyFrameAtPts:(unsigned long long)a0 withAVAsset:(id)a1;
- (void)setDisableDurationCheck:(BOOL)a0;
- (void)updateClipArray:(id)a0;
- (void)setupAudioQueue;
- (void)setAudioVolumnKeyFrameCallback:(id /* block */)a0;
- (void)seekAudioReader:(id)a0;
- (struct AudioBufferList { unsigned int x0; struct AudioBuffer { unsigned int x0; unsigned int x1; void *x2; } x1[1]; } *)renderAudioDataAtTime:(double)a0;
- (void)audioEffectProcessIfNeeded:(struct AudioBufferList { unsigned int x0; struct AudioBuffer { unsigned int x0; unsigned int x1; void *x2; } x1[1]; } *)a0;
- (void)releaseClip:(id)a0;
- (void)updateMaxDurationIfNeeded;
- (void)resetCurrentTime:(double)a0;
- (unsigned long long)p_audioFileTypeForAsset:(id)a0;
- (float)p_rateByApplyingPlayRate:(float)a0;
- (id)p_speedFilterWithConfig:(id)a0;
- (void)p_doAppendClip:(id)a0;
- (void)updateVideoAudioClips:(id)a0;
- (void)p_updateClipCacheInfo;
- (id)convertToStringWithAudioFilterType:(int)a0;
- (void)mixAudioInterleavingBufferList:(struct AudioBufferList { unsigned int x0; struct AudioBuffer { unsigned int x0; unsigned int x1; void *x2; } x1[1]; } *)a0 inBufferList:(struct AudioBufferList { unsigned int x0; struct AudioBuffer { unsigned int x0; unsigned int x1; void *x2; } x1[1]; } *)a1;
- (void)seekToTime:(double)a0 forceSeek:(BOOL)a1 completion:(id /* block */)a2;
- (void)resetCurrentRateTime:(double)a0;
- (void)seekAudioReader:(id)a0 triggerTime:(double)a1 completion:(id /* block */)a2;
- (void)setPlayRate:(double)a0 needSeek:(BOOL)a1;
- (void)p_reloadClipRateWithSeek:(BOOL)a0 currentTime:(double)a1;
- (void)appendVideoAudioClip:(id)a0 clipRange:(id)a1 videoData:(id)a2;
- (void)_updateVideoAudioClips:(id)a0;
- (void)updateSubTrackVideoAudioClipsWithVideoData:(id)a0;
- (void)hotAppendAudioAsset:(id)a0 filterArray:(id)a1 withClipRange:(id)a2 currentPlayingTime:(double)a3;
- (void)hotRemoveAudioAssets:(id)a0;
- (void)hotReloadFilterForAssets:(id)a0 inFilterMap:(id)a1;
- (id)getFilterForAssets:(id)a0;
- (void)hotReloadClipRangeForAssets:(id)a0 inRangeMap:(id)a1 currentPlayingTime:(double)a2;
- (void)resusePlayer:(id)a0;
- (void)updateSubTrackVideoAudioClips:(id)a0;
- (id)p_getCurveConfig:(id)a0;
- (BOOL)isAfterRange:(id)a0 atTime:(double)a1;
- (BOOL)isContainsInRange:(id)a0 atTime:(double)a1;
- (BOOL)isBeforeRange:(id)a0 atTime:(double)a1 tolerance:(double)a2;
- (void).cxx_destruct;
- (void)play;
- (void)pause;
- (BOOL)isPlaying;
- (void)stop;
- (void)setVolume:(float)a0;
- (void)seekToTime:(double)a0;
- (void)dealloc;
- (struct opaqueCMSampleBuffer { } *)copyNextSampleBuffer;
- (float)getVolume;

@end
